# http://lwlss.net/GarminReports/GarminFunctions.R

# manual testing do 
# test_df <- gpx_validation('C:/Users/rober/Desktop/Repositories/gpx_processing/data_backup/14-05.gpx')

gpx_validation <- function(gpxfile, ...){

  if(substring(tolower(gpxfile), nchar(gpxfile)-3) != ".gpx"){
    stop('Uploaded data needs to be .zip file. ');
  }else{
    options(stringsAsFactors = FALSE)
    tryCatch({
      data <- plotKML::readGPX(gpxfile, metadata = TRUE, bounds = TRUE, 
        waypoints = TRUE, tracks = TRUE, routes = TRUE)
      
    }, error = function(e){
      stop(cat(paste("GPX load error.", e)))
    }, finally = {
        df <- gpx_df_construct(gpxfile)
        return (df)
    })
  }
}

# Haversine formula for calculating distances from lat/long
# https://www.r-bloggers.com/great-circle-distance-calculations-in-r/
haversineDistance<-function(aLong, aLat, bLong, bLat){
  R <- 6371000 #Earth mean radius in m
  dLat <- 2 * pi * (bLat - aLat) / 360.0
  dLon <- 2 * pi * (bLong - aLong) / 360.0
  a <- (sin(dLat / 2))^2 + cos(2 * pi * aLat/360) * cos(2 * pi * bLat/360) * (sin(dLon/2)^2)
  b <- R * 2 * atan2(sqrt(a), sqrt(1 - a))
  return(b)
}

# GPX from XML to R
construct_df <- function(file){
  # options(warn=0)
  library(XML)
  doc <- xmlParse(file,useInternalNodes=TRUE)
  top <- xmlRoot(doc)
  # Identify .gpx version
  if (toString.XMLNode(top[[1]][[1]][[1]][[1]])=="Garmin International "){
    if(xmlName(top[[2]])!="trk") stop('Incomplete .GPX file')
    version <- "Garmin"
    title <- toString.XMLNode(top[[2]][[1]][[1]])
    description <- toString.XMLNode(top[[2]][[2]][[1]])
    data <- toString.XMLNode(top[[2]][[3]])
  }else if(toString.XMLNode(top[[2]][[1]])=='Geocache file generated by Groundspeak '){
    stop('Geocache file detected. Cannot be parsed.');
  }
  df <- as.data.frame(xmlToDataFrame(data))
  
  if('extensions' %in% colnames(df)) df$extensions<-NULL
  if('text' %in% colnames(df)) stop('Incomplete .GPX data')
  if(data=="NULL") data=toString.XMLNode(top[[2]][[2]])
  if(data=="NULL") data=toString.XMLNode(top[[2]][[1]])
  
  if(toString.XMLNode(top[[2]][[3]])=="NULL") {
    if(toString.XMLNode(top[[2]][[2]])=="NULL") {
      attribs=xmlSApply(top[[2]][[1]],xmlAttrs)
    }else{
      attribs=xmlSApply(top[[2]][[2]],xmlAttrs)
    }
  }else{
    attribs=xmlSApply(top[[2]][[3]],xmlAttrs)
  }
  
  df$lon=as.numeric(attribs[2,])
  df$lat=as.numeric(attribs[1,])
  
  colnames(df)=c("Elevation","DateTime","Longitude","Latitude")
  df$Elevation=as.numeric(df$Elevation)
  df$DateTime=as.character(df$DateTime)
  
  return (df)
}

# Construct dataframe from gpx file
# http://lwlss.net/GarminReports/GarminFunctions.R
gpx_df_construct <- function(gpxfile){
  
  # primary df function
  df <- construct_df(gpxfile)

  # Convert timestamp to number of seconds since start of run
  date <- substr(df$DateTime[1], 1, 10)
  Time <- substr(df$DateTime, 12, 19)
  T0 <- strptime(Time[1],"%H:%M:%S")
  Time <- as.numeric(strptime(Time,"%H:%M:%S")-T0)
  df$Seconds <- Time

  # Initialise columns
  df$dNorth <- df$dEast <- df$dUp <- df$North <- df$East <- df$dDist <- df$dDist2D <- df$Dist2D <- 0

  # Calculate northings and eastings
  df$East <- haversineDistance(df[1,"Longitude"],df[1,"Latitude"],df$Longitude,df[1,"Latitude"])*sign(df$Longitude-df[1,"Longitude"])
  df$North <- haversineDistance(df[1,"Longitude"],df[1,"Latitude"],df[1,"Longitude"],df$Latitude)*sign(df$Latitude-df[1,"Latitude"])

  # Calculate changes in position for each dt
  for (x in 2:(length(df$DateTime)-1)) {
    sEast <- sign(df[x, "Longitude"] - df[1,"Longitude"])
    sNorth <- sign(df[x, "Latitude"] - df[1,"Latitude"])
    df$dEast[x] <- sEast * haversineDistance(df[x - 1, "Longitude"],df[1, "Latitude"], df[x, "Longitude"], df[1, "Latitude"])
    df$dNorth[x] <- sNorth * haversineDistance(df[1, "Longitude"], df[x - 1, "Latitude"], df[1, "Longitude"], df[x, "Latitude"])
    df$dUp[x] <- df$Elevation[x] - df$Elevation[x - 1]
    # 2D distance (ignoring hills)
    df$dDist2D[x] <- haversineDistance(df[x - 1, "Longitude"],df[x-1, "Latitude"],df[x, "Longitude"],df[x, "Latitude"])
  }

  df$dDist <- sqrt(df$dNorth^2 + df$dEast^2 + df$dUp^2)
  df$Dist <- cumsum(df$dDist)
  df$Dist2D <- cumsum(df$dDist2D)

  # Fit a spline function to the GPS coordinates & elevation
  east <- splinefun(df$Seconds,df$East)
  north <- splinefun(df$Seconds,df$North)
  up <- splinefun(df$Seconds,df$Elevation)
  dist <- splinefun(df$Seconds,df$Dist)

  # Do finite centred differencing to give smoothest rate/gradient estimates
  df$Speed <- rep(0, length(df$Seconds))
  df$Gradient <- rep(0, length(df$Seconds))
  for(x in 2:(length(df$Seconds) - 1)){
    Dt <- df[x+1,"Seconds"]-df[x - 1,"Seconds"]
    Dd <- df[x+1,"Dist"]-df[x - 1,"Dist"]
    df[x,"Speed"] <- Dd/Dt # m/s
    df[x,"Gradient"] <- (df[x + 1,"Elevation"] - df[x - 1,"Elevation"]) / Dd # m/m
  }

  df[1, "Speed"] <- df[2, "Speed"]
  df[length(df$Seconds), "Speed"] <- df[length(df$Seconds) - 1,"Speed"]
  df[1, "Gradient"] <- df[2, "Gradient"]
  df[length(df$Seconds), "Gradient"] <- df[length(df$Seconds) - 1,"Gradient"]

  # Smooth speed as it is unrealistically noisy
  df$Speed <- smooth(df$Speed)

  # Fit a spline function to rate
  speed <- splinefun(df$Seconds, df$Speed)
  pace<-function(t) sapply(1 / speed(t), max, 0)
  ppace<-function(t) 1000 * pace(t) / 60

  # Update dataframe with speed and pace
  df$Speed <- speed(df$Seconds)
  df$Pace <- pace(df$Seconds)
  df$Speed_mph <- df$Speed*2.23694
  return(df)
}
